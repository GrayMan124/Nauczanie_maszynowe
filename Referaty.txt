1. Napisaæ funkcjê MyExtendedGCD[d__], która przy za³o¿eniu, ¿e d reprezentuje zmienn¹ liczbê argumentów bêd¹cych liczbami naturalnymi (MyExtendedGCD[d1,d2,...,di]), wyznaczy wartoœæ d=gcd(d1,...,di) oraz liczby ca³kowite: k1,...,ki: d=k1*d1+...+ki*di korzystaj¹c z Rozszerzonego Algorytmu Euklidesa oraz z w³asnoœci operacji wyznaczania najwiêkszego wspólnego dzielnika, a nastêpnie zwróci listê: {d,{k1,...,ki}}. W celu zamiany zmiennej liczby argumentów na listê mo¿emy pos³u¿yæ siê funkcj¹ wbudowan¹ List: dList=List[d];

2. Napisaæ funkcje: EncryptPlayfair[p_,key_] oraz DecryptPlayfair[c_, key_] które przy za³o¿eniu, ¿e p jest tekstem otwartym o parzystej d³ugoœci zapisanym za pomoc¹ ma³ych liter alfabetu ³aciñskiego w postaci ci¹gu znaków, c jest kryptotekstem o parzystej d³ugoœci zapisanym za pomoc¹ ma³ych liter alfabetu ³aciñskiego w postaci ci¹gu znaków, zaœ key jest niepustym ci¹giem znaków z³o¿onym z ró¿nych ma³ych liter alfabetu ³aciñskiego o d³ugoœci nie wiêkszej ni¿ 25, zaszyfruj¹ / odszyfruj¹ powy¿szy tekst otwarty / kryptotekst korzystaj¹c z kryptosystemu Playfaira z kluczem key oraz zwróc¹ otrzymany kryptotekst / tekst otwarty. Przyjmujemy, ¿e litera "i" reprezentuje zarówno literê "i", jak i literê "j";

3. Napisaæ funkcjê BreakVigenere[c_], która przy za³o¿eniu, ¿e c jest kryptotekstem zapisanym za pomoc¹ ma³ych liter alfabetu ³aciñskiego w postaci ci¹gu znaków, powsta³ym poprzez zaszyfrowanie pewnego tekstu otwartego stanowi¹cego poprawny tekst zapisany w jêzyku angielskim za pomoc¹ ma³ych liter alfabetu bez znaku spacji, pos³uguj¹c siê statystyczn¹ metod¹ Friedmana wyznaczy, a nastêpnie zwróci ci¹g znaków reprezentuj¹cy najbardziej prawdopodobny tekst otwarty. Przetestowaæ poprawnoœæ dzia³ania funkcji na kryptotekstach zapisanych w zmiennych o nazwach: vvhq, ocwy, xkju oraz hdsf w notebooku œrodowiska Mathematica o nazwie crypto6.nb. Lista czêstoœci wystêpowania poszczególnych liter jêzyka angielskiego zapisana jest w tym samym notebooku w zmiennej o nazwie alfreq;

4. Napisaæ funkcje: EncryptMerkleHellman[m_,B_] oraz DecryptMerkleHellman[c_,W_,q_,r_], które przy za³o¿eniu, ¿e m jest tekstem otwartym bêd¹cym liczb¹ naturaln¹, c jest kryptotekstem bêd¹cym liczb¹ ca³kowit¹, zaœ B oraz W s¹ listami, przy pozosta³ych za³o¿eniach i oznaczeniach analogicznych jak w artykule zamieszczonym na ³amach angielskojêzycznej Wikipedii dotycz¹cym kryptosystemu Merkle-Hellmana (kryptosystemu plecakowego), dokonaj¹ zaszyfrowania / odszyfrowania odpowiedniego tekstu otwartego / kryptotekstu korzystaj¹c z kryptosystemu Merkle-Hellmana, a nastêpnie zwróc¹ otrzymany kryptotekst / tekst otwarty. Zak³adamy, ¿e poszczególne bity tekstu otwartego zakodowane s¹ w postaci jednej liczby naturalnej mniejszej ni¿ 2^(liczba elementów wektora publicznego B) w taki sposób, ¿e m=m1*2^0+...+mn*2^(n-1);

5. W dowolny sposób zilustrowaæ w œrodowisku Mathematica testy pierwszoœci Fermata oraz Millera-Rabina;
6. W dowolny sposób zilustrowaæ w œrodowisku Mathematica algorytmy faktoryzacji: p-1 oraz Universal Exponent Factorization;

7. Napisaæ funkcjê L[alpha_,beta_,p_], która przy za³o¿eniu, ¿e argument alpha jest pierwiastkiem prymitywnym (mod p), beta=alpha^x(mod p) dla 0<=x<p, zaœ p jest liczb¹ pierwsz¹, wyznaczy, a nastêpnie zwróci wartoœæ x korzystaj¹c z metody redukcji Pohliga-Hellmana;

8. Kryptoanaliza systemu Vigenere'a: podstawy teoretyczne (wyznaczanie najbardziej prawdopodobnej d³ugoœci klucza, wyznaczanie najbardziej prawdopodobnego klucza);
9. Kryptosystem Merkle-Hellmana (kryptosystem plecakowy): podstawy teoretyczne + dowód poprawnoœci;
10. Testy pierwszoœci Fermata oraz Millera-Rabina: podstawy teoretyczne + dowód poprawnoœci;
11. Algorytmy faktoryzacji p-1 oraz Universal Exponent Factorization: podstawy teoretyczne + dowód poprawnoœci;
12. Metoda redukcji Pohliga-Hellmana: podstawy teoretyczne + dowód poprawnoœci;
13. Zestaw nr 6, zadanie 1: zastosowanie kryptoanalizy ró¿nicowej w celu prze³amania (znalezienia klucza) w 3-rundowym systemie DES omawianym na wyk³adzie;
14. Dowolna implementacja w œrodowisku Mathematica funkcji szyfruj¹cej ci¹g bitów z wykorzystaniem 3-rundowego systemu DES omawianego na wyk³adzie;
15. W dowolny sposób zilustrowaæ w œrodowisku Mathematica proces weryfikacji podpisu cyfrowego z wykorzystaniem algorytmów: RSA oraz ElGamal;
16. Krzywe eliptyczne: definicja (postaæ równania, regularnoœæ), struktura grupy wraz z operacj¹ dodawania punktów;
17. Krzywe eliptyczne: wyprowadzenie warunku regularnoœci krzywej eliptycznej (elementarne - wynika z definicji regularnoœci z Analizy II) + wyprowadzenie wzoru na sumê dwóch punktów le¿¹cych na krzywej eliptycznej (elementarne - korzysta siê ze wzorów Viete'a);
18. Algorytm Tonellego-Shanksa rozwi¹zywania kongruencji kwadratowych (mod p), gdzie p - liczba pierwsza: dowolna implementacja w œrodowisku Mathematica;
19. Algorytm Tonellego-Shanksa rozwi¹zywania kongruencji kwadratowych (mod p), gdzie p - liczba pierwsza: krótki zarys podstaw teoretycznych;
20. Inny, zaproponowany przez siebie temat po konsultacji z prowadz¹cym;